#!/usr/bin/env python
# Code generator for trace events
#
# Copyright IBM, Corp. 2011
#
# This work is licensed under the terms of the GNU GPL, version 2.  See
# the COPYING file in the top-level directory.
#
#

import sys
import getopt
import re

def usage():
    print "Tracetool: Generate tracing code for trace events file on stdin"
    print "Usage:"
    print sys.argv[0], "--backend=[nop|simple|stderr|dtrace|ust] [-h|-c|-d|--stap]"
    print '''
Backends:
  --nop     Tracing disabled
  --simple  Simple built-in backend
  --stderr  Stderr built-in backend
  --dtrace  DTrace/SystemTAP backend
  --ust     LTTng User Space Tracing backend

Output formats:
  -h     Generate .h file
  -c     Generate .c file
  -d     Generate .d file (DTrace only)
  --stap Generate .stp file (DTrace with SystemTAP only)

Options:
  --binary       [path]    Full path to QEMU binary
  --target-arch  [arch]    QEMU emulator target arch
  --target-type  [type]    QEMU emulator target type ('system' or 'user')
  --probe-prefix [prefix]  Prefix for dtrace probe names
                           (default: qemu-targettype-targetarch)
'''
    sys.exit(1)

def trace_h_begin():
    print '''#ifndef TRACE_H
#define TRACE_H

/* This file is autogenerated by tracetool, do not edit. */

#include "qemu-common.h"'''


def trace_h_end():
    print '#endif /* TRACE_H */'


def trace_c_begin():
    print '/* This file is autogenerated by tracetool, do not edit. */'

def trace_c_end():
    pass # nop, required for trace_gen

def nop_h(events):
    print
    for event in events:
        print '''static inline void trace_%(name)s(%(args)s)
{
}
''' % {
    'name': event.name,
    'args': event.args
}
    return

def nop_c(events):
    pass # nop, reqd for converters

def simple_h(events):
    print '#include "trace/simple.h"'
    print

    for num, event in enumerate(events):
        if len(event.args):
            argstr = event.args.names()
            arg_prefix = ', (uint64_t)(uintptr_t)'
            cast_args = arg_prefix + arg_prefix.join(argstr)
            simple_args = (str(num) + cast_args)
        else:
            simple_args = str(num)

        print '''static inline void trace_%(name)s(%(args)s)
{
    trace%(argc)d(%(trace_args)s);
}''' % {
    'name': event.name,
    'args': event.args,
    'argc': len(event.args),
    'trace_args': simple_args
}
        print
    print '#define NR_TRACE_EVENTS %d' % len(events)
    print 'extern TraceEvent trace_list[NR_TRACE_EVENTS];'


def simple_c(events):
    print '#include "trace.h"'
    print
    print 'TraceEvent trace_list[] = {'
    print

    for event in events:
        print '{.tp_name = "%(name)s", .state=0},' % {
    'name': event.name,
}
        print
    print '};'

def stderr_h(events):
    print '''#include <stdio.h>
#include "trace/stderr.h"

extern TraceEvent trace_list[];'''
    for num, event in enumerate(events):
        argnames = ", ".join(event.args.names())
        if len(event.args) > 0:
            argnames = ", " + argnames
        print '''
static inline void trace_%(name)s(%(args)s)
{
    if (trace_list[%(event_num)s].state != 0) {
        fprintf(stderr, "%(name)s " %(fmt)s "\\n" %(argnames)s);
    }
}''' % {
    'name': event.name,
    'args': event.args,
    'event_num': num,
    'fmt': event.fmt,
    'argnames': argnames
}
    print
    print '#define NR_TRACE_EVENTS %d' % len(events)

def stderr_c(events):
    print '''#include "trace.h"

TraceEvent trace_list[] = {
'''
    for event in events:
        print '{.tp_name = "%(name)s", .state=0},' % {
    'name': event.name
}
        print
    print '};'

def ust_h(events):
    print '''#include <ust/tracepoint.h>
#undef mutex_lock
#undef mutex_unlock
#undef inline
#undef wmb'''

    for event in events:
        if len(event.args) > 0:
            print '''
DECLARE_TRACE(ust_%(name)s, TP_PROTO(%(args)s), TP_ARGS(%(argnames)s));
#define trace_%(name)s trace_ust_%(name)s''' % {
    'name': event.name,
    'args': event.args,
    'argnames': ", ".join(event.args.names())
}
        else:
            print '''
_DECLARE_TRACEPOINT_NOARGS(ust_%(name)s);
#define trace_%(name)s trace_ust_%(name)s''' % {
    'name': event.name,
}
    print

def ust_c(events):
    print '''#include <ust/marker.h>
#undef mutex_lock
#undef mutex_unlock
#undef inline
#undef wmb
#include "trace.h"'''
    for event in events:
        argnames = ", ".join(event.args.names())
        if len(event.args) > 0:
            argnames = ', ' + argnames
            print '''
DEFINE_TRACE(ust_%(name)s);

static void ust_%(name)s_probe(%(args)s)
{
    trace_mark(ust, %(name)s, %(fmt)s%(argnames)s);
}''' % {
    'name': event.name,
    'args': event.args,
    'fmt': event.fmt,
    'argnames': argnames
}
        else:
            print '''
DEFINE_TRACE(ust_%(name)s);

static void ust_%(name)s_probe(%(args)s)
{
    trace_mark(ust, %(name)s, UST_MARKER_NOARGS);
}''' % {
    'name': event.name,
    'args': event.args,
}

    # register probes
    print '''
static void __attribute__((constructor)) trace_init(void)
{'''
    for event in events:
        print '    register_trace_ust_%(name)s(ust_%(name)s_probe);' % {
    'name': event.name
}
    print '}'

def dtrace_h(events):
    print '#include "trace-dtrace.h"'
    print
    for event in events:
        print '''static inline void trace_%(name)s(%(args)s) {
    if (QEMU_%(uppername)s_ENABLED()) {
        QEMU_%(uppername)s(%(argnames)s);
    }
}
''' % {
    'name': event.name,
    'args': event.args,
    'uppername': event.name.upper(),
    'argnames': ", ".join(event.args.names()),
}

def dtrace_c(events):
    pass # No need for function definitions in dtrace backend

def dtrace_d(events):
    print 'provider qemu {'
    for event in events:
        args = event.args

        # DTrace provider syntax expects foo() for empty
        # params, not foo(void)
        if args == 'void':
            args = ''

        # Define prototype for probe arguments
        print '''
        probe %(name)s(%(args)s);''' % {
        'name': event.name,
        'args': args
}
    print
    print '};'

def dtrace_nop_d(events):
    pass

def dtrace_stp(events):
    for event in events:
        # Define prototype for probe arguments
        print '''
probe %(probeprefix)s.%(name)s = process("%(binary)s").mark("%(name)s")
{''' % {
    'probeprefix': probeprefix,
    'name': event.name,
    'binary': binary
}
        i = 1
        if len(event.args) > 0:
            for name in event.args.names():
                # 'limit' is a reserved keyword
                if name == 'limit':
                    name = '_limit'
                print '  %s = $arg%d;' % (name.lstrip(), i)
                i += 1
        print '}'
    print

def dtrace_nop_stp(events):
    pass

def trace_stap_begin():
    print '/* This file is autogenerated by tracetool, do not edit. */'

def trace_stap_end():
    pass #nop, reqd for trace_gen

def trace_d_begin():
    print '/* This file is autogenerated by tracetool, do not edit. */'

def trace_d_end():
    pass #nop, reqd for trace_gen


# Registry of backends and their converter functions
converters = {
    'simple': {
        'h': simple_h,
        'c': simple_c,
    },

    'nop': {
        'h': nop_h,
        'c': nop_c,
        'd': dtrace_nop_d,
        'stap': dtrace_nop_stp,
    },

    'stderr': {
        'h': stderr_h,
        'c': stderr_c,
    },

    'dtrace': {
        'h': dtrace_h,
        'c': dtrace_c,
        'd': dtrace_d,
        'stap': dtrace_stp
    },

    'ust': {
        'h': ust_h,
        'c': ust_c,
    },

}

# Trace file header and footer code generators
trace_gen = {
    'h': {
        'begin': trace_h_begin,
        'end': trace_h_end,
    },
    'c': {
        'begin': trace_c_begin,
        'end': trace_c_end,
    },
    'd': {
        'begin': trace_d_begin,
        'end': trace_d_end,
    },
    'stap': {
        'begin': trace_stap_begin,
        'end': trace_stap_end,
    },
}

# Event arguments
class Arguments:
    def __init__ (self, arg_str):
        self._args = []
        for arg in arg_str.split(","):
            arg = arg.strip()
            parts = arg.split()
            head, sep, tail = parts[-1].rpartition("*")
            parts = parts[:-1]
            if tail == "void":
                assert len(parts) == 0 and sep == ""
                continue
            arg_type = " ".join(parts + [ " ".join([head, sep]).strip() ]).strip()
            self._args.append((arg_type, tail))

    def __iter__(self):
        return iter(self._args)

    def __len__(self):
        return len(self._args)

    def __str__(self):
        if len(self._args) == 0:
            return "void"
        else:
            return ", ".join([ " ".join([t, n]) for t,n in self._args ])

    def names(self):
        return [ name for _, name in self._args ]

    def types(self):
        return [ type_ for type_, _ in self._args ]

# A trace event
cre = re.compile("((?P<props>.*)\s+)?(?P<name>[^(\s]+)\((?P<args>[^)]*)\)\s*(?P<fmt>\".*)?")

VALID_PROPS = set(["disable"])

class Event(object):
    def __init__(self, line):
        m = cre.match(line)
        assert m is not None
        groups = m.groupdict('')
        self.name = groups["name"]
        self.fmt = groups["fmt"]
        self.properties = groups["props"].split()
        self.args = Arguments(groups["args"])

        unknown_props = set(self.properties) - VALID_PROPS
        if len(unknown_props) > 0:
            raise ValueError("Unknown properties: %s" % ", ".join(unknown_props))

# Generator that yields Event objects given a trace-events file object
def read_events(fobj):
    res = []
    for line in fobj:
        if not line.strip():
            continue
        if line.lstrip().startswith('#'):
	    continue
        res.append(Event(line))
    return res

binary = ""
probeprefix = ""

def main():
    global binary, probeprefix
    targettype = ""
    targetarch = ""
    supported_backends = ["simple", "nop", "stderr", "dtrace", "ust"]
    short_options = "hcd"
    long_options = ["stap", "backend=", "binary=", "target-arch=", "target-type=", "probe-prefix=", "list-backends", "check-backend"]
    try:
        opts, args = getopt.getopt(sys.argv[1:], short_options, long_options)
    except getopt.GetoptError, err:
        # print help information and exit:
        print str(err) # will print something like "option -a not recognized"
        usage()
        sys.exit(2)
    for opt, arg in opts:
        if opt == '-h':
            output = 'h'
        elif opt == '-c':
            output = 'c'
        elif opt == '-d':
            output = 'd'
        elif opt == '--stap':
            output = 'stap'
        elif opt == '--backend':
            backend = arg
        elif opt == '--binary':
            binary = arg
        elif opt == '--target-arch':
            targetarch = arg
        elif opt == '--target-type':
            targettype = arg
        elif opt == '--probe-prefix':
            probeprefix = arg
        elif opt == '--list-backends':
            print 'simple, nop, stderr, dtrace, ust'
            sys.exit(0)
        elif opt == "--check-backend":
            if any(backend in s for s in supported_backends):
                sys.exit(0)
            else:
                sys.exit(1)
        else:
            #assert False, "unhandled option"
            print "unhandled option: ", opt
            usage()

    if backend == "" or output == "":
        usage()
        sys.exit(0)

    if backend != 'dtrace' and output == 'd':
        print 'DTrace probe generator not applicable to %s backend' % backend
        sys.exit(1)

    if output == 'stap':
        if backend != "dtrace":
            print 'SystemTAP tapset generator not applicable to %s backend' % backend
            sys.exit(1)
        if binary == "":
            print '--binary is required for SystemTAP tapset generator'
            sys.exit(1)
        if not probeprefix and  not targettype:
            print '--target-type is required for SystemTAP tapset generator'
            sys.exit(1)
        if not probeprefix and  not targetarch:
            print '--target-arch is required for SystemTAP tapset generator'
            sys.exit(1)
        if probeprefix == "":
            probeprefix = 'qemu.' + targettype + '.' + targetarch

    events = read_events(sys.stdin)

    trace_gen[output]['begin']()
    converters[backend][output]([ e for e in events if 'disable' not in e.properties ])
    converters['nop'][output]([ e for e in events if 'disable' in e.properties ])
    trace_gen[output]['end']()

if __name__ == "__main__":
    main()

